# 面向对象
## 面向对象三大机制
1. 封装 隐藏内部实现
2. 继承 复用现有代码
3. 多态 改写对象行为

软件设计复杂性在于**变化**   
如何解决？ 分解 **抽象**    
软件设计的金科玉律 **复用**   
变化是复用的天敌   
面向对象设计最大的优势在于**抵御变化**

## 重新认识面向对象
1. 宏观层面 面向对象更能适应软件的变化，能将变化带来的影响减为最小（隔离变化）
2. 微观层面 面向对象更强调类的责任，由于变化导致的新增类型不应该影响原来类型的实现（各司其职）
3. 对象是什么   
(1) 语言层面上，对象封装了代码和数据   
(2) 规格层面上，对象是一系列可被使用的公共接口   
(3) 概念层面上，对象是某种拥有责任的抽象



# 设计模式六大原则
## 1.单一职责原则
定义：不要存在多于一个导致类变更的原因，即一个类只负责一项职责。

优点：降低类的复杂度，提高类的可读性，变更引起的风险降低（减少了耦合度）。
## 2.里氏代换原则
定义：所有父类出现的地方都能用子类替换而不会出现错误，即子类可以扩展父类的功能，但不能改变原有的功能。

优点：减少了继承所带来的错误风险。
## 3.依赖倒置原则
定义：高层模块不应该依赖低层模块，二者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

依赖倒置的核心思想就是面向接口编程。
## 4.接口隔离原则
定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

建立单一接口，不要建立庞大臃肿的接口，接口应细化，接口中的方法尽量少。即建立类的专用接口。使用要限度，否则会产生导致接口数量过多，使设计复杂化。
## 5.迪米特法则
定义：一个对象应该和其他对象保持最少的了解。（只与直接的朋友通信）

即降低类之间的耦合，逻辑尽量封装在类内部，对外只暴露接口。过分的使用会导致出现大量中介和传递类，使系统复杂性变大。
## 6.开闭原则
定义：对扩展开放，对修改封闭。 

在程序需要拓展的时候，不能修改原有的代码，使用接口和抽象类来实现“热插拔”的效果。用抽象搭建框架，用实现扩展细节。对23种设计模式的合理使用和对上面5条规则的合理遵守就是对开闭原则的遵守。

# 23种设计模式
## 分类
从目的来看：
1. 创建型模式 将对象的部分创建工作延迟到子类或其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。
2. 结构型模式 通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
3. 行为型模式 通过类继承和对象组合来划分类与对象间的职责，从而应对需求变化为多个交互对象带来的冲击。

从范围来看：
1. 类模式处理类与子类的静态关系。
2. 对象模式处理对象间的动态关系。

## 要点 
**寻找变化点，然后在变化点处应用设计模式**  
设计模式就是把变化关进笼子   
忌先入为主使用设计模式，提倡Refactoring to Patterns（通过重构实现模式）  
重构技法
1. 静态->动态
2. 早绑定->晚绑定
3. 继承->组合
4. 编译时依赖->运行时依赖
5. 紧耦合->松耦合


## 模板方法 Template Method
### 动机
在软件构建过程中，对于某一项任务，常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架和应用之间的关系）而无法和任务的整体结构同时实现。
### 模式定义
定义一个操作中的算法的骨骼（稳定点），而将一些步骤（变化点）延迟到子类中。模板方法使得子类可以不改变一个算法的结构（复用）即可重定义（override重写）该算法的某些特定步骤。
### 要点总结
1. 模板模式是一种非常基础的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
2. 除了可以灵活应对子步骤的变化外，**不要调用我，让我来调用你**的反向控制结构是模板方法的典型应用。
3. 在具体实现方面，被模板方法调用的虚方法可以有具体实现，也可以没有任何实现（抽象方法，纯虚方法），但一般建议将他们设置为protected方法。
### 模式实例
unity生命周期，方法调用的顺序已经固定，我们通过重写方法实现不同需求。

## 策略模式 Strategy
### 动机
在软件构建过程中，某些对象使用的算法可能多种多样，经常改变。如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一种性能负担。
### 模式定义
定义一系列算法，把它们一个个封装起来，并且使他们可互相替换（变化点）。该模式使得算法可独立于使用它的客户程序（稳定点）而变化。
### 要点总结
Strategy及其子类为组件提供了一系列可重用的算法，从而使得类型在**运行时**方便地根据需要在各个算法之间进行切换。   
Strategy提供了用条件判断以外的另一种选择，消除条件判断语句就是在解耦合。含有许多条件判断语句的代码（bad smell）通常需要Strategy模式。   
如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。   
### 模式实例
对于税金的计算，不同国家有着不同的算法。设计一个计算税金的软件可以使用策略模式包装每一种算法。

## 观察者模式 Observer
### 动机
在软件构建中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
### 模式定义
定义对象间的一种一对多（变化点）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。   
注意：观察者模式与发布订阅模式有所不同。观察者模式中有两个角色，为观察者和被观察者，他们之间是松耦合的关系。而发布订阅模式在二者之间还有一个经纪人（例如消息队列等中间件），二者完全解耦。
### 要点总结
使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合。   
目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。   
观察者自己决定是否需要订阅通知，目标对象对此一无所知。   
Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。
### 模式实例
订阅公众号，每当有新信息时推送到订阅者。

## 装饰模式 Decorator
### 动机
在某些情况下我们可能会过度使用继承来扩展对象的功能，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
### 模式定义
动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）。
### 要点总结
通过采用组合而非继承的方法，Decorator模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生”问题。   
Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。   
Decorator模式的目的并非解决“多子类衍生的多继承问题”，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。
### 模式实例
穿衣服是使用装饰的一个例子。觉得冷时，你可以穿一件毛衣。如果穿毛衣还觉得冷，你可以再套上一件夹克。如果遇到下雨，你还可以再穿一件雨衣。所有这些衣物都“扩展”了你的基本行为，但它们并不是你的一部分，如果你不再需要某件衣物，可以方便地随时脱掉。

## 桥接模式 Bridge
### 动机
由于某些类型的固有的实现逻辑，使得它们具有两个乃至多个维度的变化。
### 模式定义
将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。
### 要点总结
Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。   
Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则，复用性比较差。Bridge模式是比多继承方案更好的解决方法。   
Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以用Bridge的扩展模式。
### 模式实例
一个软件的平台实现和业务功能可以使用桥接模式分离。

## 工厂方法 Factory Method
### 动机
在软件系统中，经常面临着创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化。
### 模式定义
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到子类（目的：解耦，手段：虚函数）。
### 要点总结
Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。   
Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。   
Factory Method模式解决“单个对象” 的需求变化。缺点在于要求创建方法/参数相同。
### 模式实例
开发跨平台UI组件，button的创建使用工厂方法。

## 抽象工厂 Abstract Factory
### 动机
在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作。同时，由于需求的变化，往往存在更多系列对象的创建工作。
### 模式定义
提供一个接口，让该接口负责创建一系列“相关或互相依赖的对象”，无需指定它们具体的类。
### 要点总结
如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂模式完全可以。   
“系列对象”指的是在某一特定系列下的对象之间有相互依赖或作用的关系。不同系列的对象之间不能相互依赖。   
Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。
### 模式实例
不同平台一组UI组件的创建。

## 原型模式 Prototype
### 动机
在软件系统中，经常面临着“某些结构复杂的对象”的创建工作。由于需求的变化，这些对象经常面临着剧烈的变化，但他们却拥有比较稳定一致的接口。   
### 模式定义
使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。   
### 要点总结
Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。   
Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象。所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。   
Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。
### 模式实例
细胞分裂

## 构建器 Builder
### 动机
在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
### 模式定义
将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。
### 要点总结
Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。   
变化点在哪里，封装哪里——Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。   
在Builder模式中，要注意不同语言中构造器内调用虚函数的差别。
### 模式实例
房屋的建造流程可以抽象为相同的算法，其中每个步骤可以有所不同，例如建造木屋和石屋。

## 单例模式 Singleton
### 动机
在软件设计中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
### 模式定义
保证一个类仅有一个实例，并提供一个该实例的全局访问点。
### 要点总结
Singleton模式中的实例构造器可以设置为protected以允许子类派生。   
Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷相违背。   
如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。（最好的方法是Meyer's Singleton，即采用静态局部变量）
### 模式实例
任务管理器 回收站 网站计数器 日志应用 线程池 文件系统

## 享元模式 Flyweight
### 动机
在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。   
### 模式定义
运用共享技术有效地支持大量细粒度地对象。
### 要点总结
面向对象很好地解决了抽象性的问题，但是作为一个在机器运行中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。   
Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。（一般对象为只读）   
对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。
### 模式实例
线程池 对象池（类似思想）

## 门面（外观）模式 Facade 计算机问题都可以通过增加一个中间层来解决，如果不能，就再加一层
### 动机
软件设计中会出现组件的客户和组件中各种复杂的子系统有过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
### 模式定义
为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。
### 要点总结
从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。   
Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。   
Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件地内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。
### 模式实例
专属客服

## 代理模式 Proxy
### 动机
在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。
### 模式定义
为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。
### 要点总结
“增加一层中间层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。   
具体proxy设计模式的使用方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。   
Proxy并不一定要求保持接口完整的一致性，只要能实现间接控制，有时候损及一些透明性是可以接受的。
### 模式实例
字符串的copy-on-write 信用卡相对于现金是一种代理

## 适配器模式 Adapter
### 动机
在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放到新的环境中应用，但是新环境要求的接口是这些现存对象不满足的。
### 模式定义
将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
### 要点总结
Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。   
GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。   
Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。
### 模式实例
STL中的stack和queue 电脑各种接口的转换器

## 中介者模式 Mediator
### 动机
在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。
### 模式定义
用一个中介者对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖->运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。
### 要点总结
将多个对象间复杂的关系解耦，Mediator模式将多个对象间地控制逻辑进行集中管理，变“多个对象互相关联”（网状结构）为“多个对象和一个中介者关联”（星型），简化了系统的维护，抵御了可能的变化。   
随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。   
Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。
### 模式实例
飞机场的塔台 消息队列中间件

## 状态模式 State
### 动机
在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。
### 模式定义
允许一个对象在其内部状态发生改变时改变它的行为。从而使对象看起来似乎修改了其行为。
### 要点总结
State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了集体操作与状态转换之间的解耦。   
为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。   
如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。
### 模式实例
unity动画控制器  

## 备忘录模式 Memento
### 动机
在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个时间点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的实现细节。
### 模式定义
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
### 要点总结
备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。   
Memento模式的核心是信息隐藏，即Originator需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界。   
由于现代语言运行时（C#，JAVA）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。
### 模式实例
游戏存档

## 组合模式 Composite
### 动机
软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）地变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。
### 模式定义
将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。
### 要点总结
Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个对象还是组合的对象容器。（多态递归调用）   
将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非容器对象的内部实现结构——发生依赖，从而更能“应对变化”。   
Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。
### 模式实例
树形结构出现的地方 文件目录显示

## 迭代器 Iterator
### 动机
在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。
### 模式定义
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。
### 要点总结
迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。   
迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同集合结构上进行操作。   
迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。
### 模式实例
目前在c++中该模式已被通过模板编程（性能高）实现的迭代器所取代。

## 职责链 Chain of Responsibility
### 动机
在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少地带来请求发送者与接受者的紧耦合。
### 模式定义
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
### 要点总结
Chain of Responsibility模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。   
应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。   
如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接收对象的责任，而不是发出请求的对象的责任。

## 命令模式 Command
### 动机
在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种紧耦合。但在某些场合——比如需要对行为进行“undo/redo”等处理，这种无法抵御变化的紧耦合是不合适的。
### 模式定义
将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
### 要点总结
Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。   
实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令”封装为一个复合命令。   
Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。

## 访问器 Visitor
### 动机
在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。
### 模式定义
表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。
### 要点总结
Visitor模式通过所谓双重分发来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作。   
所谓双重分发即Visitor模式中间包括了两个多态分发：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。   
Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor类的改变（依赖具体）。因此Visitor模式适用于Element类层次结构稳定，而其中的操作却经常面临着频繁改动。

## 解析器 Interpreter
### 动机
在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果用普通的编程方式来实现将面临非常频繁的变化。
### 模式定义
给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。
### 要点总结
Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用。   
使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展文法”。   
Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。

## 设计模式总结
一个目标 **管理变化，提高复用**   
两种手段 **分解 抽象**
### 什么时候不用模式
代码可读性很差时   
需求理解还很浅时   
变化没有显现时   
不是系统的关键依赖点   
项目没有复用价值时   
项目将要发布时
### 经验之谈
不要为模式而模式   
关注抽象类&接口   
理清变化点和稳定点   
审视依赖关系   
要有Framework和Application的区隔思维   
良好的设计是演化的结果